{"ast":null,"code":"import * as i0 from \"@angular/core\";\nclass Trie {\n  constructor() {\n    this.root = this.createNode();\n  }\n  createNode() {\n    return {\n      children: {},\n      isEndOfWord: false\n    };\n  }\n  insert(word) {\n    let node = this.root;\n    for (const char of word) {\n      if (!node.children[char]) {\n        node.children[char] = this.createNode();\n      }\n      node = node.children[char];\n    }\n    node.isEndOfWord = true;\n  }\n  search(word) {\n    let node = this.root;\n    for (const char of word) {\n      if (!node.children[char]) {\n        return false;\n      }\n      node = node.children[char];\n    }\n    return node.isEndOfWord;\n  }\n  startsWith(prefix) {\n    let node = this.root;\n    for (const char of prefix) {\n      if (!node.children[char]) {\n        return false;\n      }\n      node = node.children[char];\n    }\n    return true;\n  }\n  getWords(prefix) {\n    let node = this.root;\n    const words = [];\n    for (const char of prefix) {\n      if (!node.children[char]) {\n        return words;\n      }\n      node = node.children[char];\n    }\n    this.collectWords(node, prefix, words);\n    return words;\n  }\n  collectWords(node, prefix, words) {\n    if (node.isEndOfWord) {\n      words.push(prefix);\n    }\n    for (const char in node.children) {\n      this.collectWords(node.children[char], prefix + char, words);\n    }\n  }\n}\nexport let SearchService = /*#__PURE__*/(() => {\n  class SearchService {\n    constructor() {\n      this.trie = new Trie();\n      this.initializeTrips();\n    }\n    initializeTrips() {\n      const trips = ['New York', 'Los Angeles', 'San Francisco', 'Las Vegas'];\n      trips.forEach(trip => this.trie.insert(trip));\n    }\n    searchTrips(query) {\n      if (this.trie.startsWith(query)) {\n        return this.trie.getWords(query);\n      }\n      return this.fuzzySearch(query);\n    }\n    fuzzySearch(query) {\n      const trips = ['New York', 'Los Angeles', 'San Francisco', 'Las Vegas'];\n      return trips.filter(trip => this.levenshteinDistance(query, trip) <= 2);\n    }\n    levenshteinDistance(a, b) {\n      const matrix = [];\n      for (let i = 0; i <= b.length; i++) {\n        matrix[i] = [i];\n      }\n      for (let j = 0; j <= a.length; j++) {\n        matrix[0][j] = j;\n      }\n      for (let i = 1; i <= b.length; i++) {\n        for (let j = 1; j <= a.length; j++) {\n          if (b.charAt(i - 1) === a.charAt(j - 1)) {\n            matrix[i][j] = matrix[i - 1][j - 1];\n          } else {\n            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));\n          }\n        }\n      }\n      return matrix[b.length][a.length];\n    }\n    static #_ = this.ɵfac = function SearchService_Factory(t) {\n      return new (t || SearchService)();\n    };\n    static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: SearchService,\n      factory: SearchService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return SearchService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}